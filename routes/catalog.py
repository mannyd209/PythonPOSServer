from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional
from pydantic import BaseModel, Field
from decimal import Decimal

from models import Staff, Category, Item, ModList, Mod, StaffRole, get_db
from utils.auth import get_current_staff

router = APIRouter(
    prefix="/catalog",
    tags=["Catalog"],
    responses={
        401: {"description": "Not authenticated"},
        403: {"description": "Not authorized (Manager/Admin only)"},
        404: {"description": "Item not found"},
    }
)

# Pydantic models for request/response
class ModCreate(BaseModel):
    """Modifier creation model"""
    name: str = Field(..., min_length=1, description="Name of the modifier")
    price_addition: float = Field(
        default=0.0,
        ge=0,
        description="Additional price for this modifier"
    )
    sort_order: int = Field(
        default=0,
        description="Display order (lower numbers first)"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Extra Cheese",
                "price_addition": 1.50,
                "sort_order": 1
            }
        }

class ModUpdate(BaseModel):
    """Modifier update model"""
    name: Optional[str] = Field(None, min_length=1, description="Name of the modifier")
    price_addition: Optional[float] = Field(
        None,
        ge=0,
        description="Additional price for this modifier"
    )
    sort_order: Optional[int] = Field(
        None,
        description="Display order (lower numbers first)"
    )
    active: Optional[bool] = Field(
        None,
        description="Whether this modifier is available"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Extra Cheese",
                "price_addition": 2.00,
                "active": True
            }
        }

class ModListCreate(BaseModel):
    """Modifier list creation model. ID is auto-generated by the backend."""
    name: str = Field(..., min_length=1, description="Name of the modifier list")
    min_selections: int = Field(
        default=0,
        ge=0,
        description="Minimum number of selections required"
    )
    max_selections: int = Field(
        None,
        description="Maximum number of selections allowed (null for unlimited)"
    )
    sort_order: int = Field(
        default=0,
        description="Display order (lower numbers first)"
    )
    available: bool = Field(default=True, description="Whether this modifier list is available")
    mods: List[ModCreate] = Field(
        default=[],
        description="List of modifiers in this list"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Extra Toppings",
                "min_selections": 0,
                "max_selections": 3,
                "sort_order": 1,
                "available": true,
                "mods": [
                    {
                        "name": "Extra Cheese",
                        "price_addition": 1.50,
                        "sort_order": 1
                    }
                ]
            }
        }

class ModListUpdate(BaseModel):
    """Modifier list update model"""
    name: Optional[str] = Field(None, min_length=1, description="Name of the modifier list")
    min_selections: Optional[int] = Field(
        None,
        ge=0,
        description="Minimum number of selections required"
    )
    max_selections: Optional[int] = Field(
        None,
        description="Maximum number of selections allowed (null for unlimited)"
    )
    sort_order: Optional[int] = Field(
        None,
        description="Display order (lower numbers first)"
    )
    active: Optional[bool] = Field(
        None,
        description="Whether this modifier list is available"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Extra Toppings",
                "min_selections": 0,
                "max_selections": 5,
                "active": True
            }
        }

class ItemCreate(BaseModel):
    """Item creation model. ID is auto-generated by the backend."""
    name: str = Field(..., min_length=1, description="Name of the item")
    category_id: int = Field(..., description="ID of the category this item belongs to (must be a valid six-digit category ID)")
    reg_price: float = Field(
        ...,
        ge=0,
        description="Regular price of the item"
    )
    event_price: float = Field(
        ...,
        ge=0,
        description="Event price of the item"
    )
    sort_order: int = Field(
        default=0,
        description="Display order (lower numbers first)"
    )
    available: bool = Field(default=True, description="Whether this item is available")

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Margherita Pizza",
                "category_id": 100001,
                "reg_price": 12.99,
                "event_price": 15.99,
                "sort_order": 1,
                "available": true
            }
        }

class ItemUpdate(BaseModel):
    """Item update model"""
    name: Optional[str] = Field(None, min_length=1, description="Name of the item")
    category_id: Optional[int] = Field(None, description="ID of the category")
    price: Optional[float] = Field(
        None,
        ge=0,
        description="Base price of the item"
    )
    sort_order: Optional[int] = Field(
        None,
        description="Display order (lower numbers first)"
    )
    active: Optional[bool] = Field(
        None,
        description="Whether this item is available"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Margherita Pizza",
                "price": 13.99,
                "active": True
            }
        }

class CategoryCreate(BaseModel):
    """Category creation model. ID is auto-generated by the backend as a six-digit number (100000-999999)."""
    name: str = Field(..., min_length=1, description="Name of the category")
    sort_order: int = Field(
        default=0,
        description="Display order (lower numbers first)"
    )
    available: bool = Field(default=True, description="Whether this category is available")

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Pizzas",
                "sort_order": 1,
                "available": True
            }
        }

class CategoryUpdate(BaseModel):
    """Category update model"""
    name: Optional[str] = Field(None, min_length=1, description="Name of the category")
    sort_order: Optional[int] = Field(
        None,
        description="Display order (lower numbers first)"
    )
    active: Optional[bool] = Field(
        None,
        description="Whether this category is available"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Pizzas",
                "active": True
            }
        }

# Helper function to check manager/admin role
def check_manager_role(staff: Staff):
    """Check if staff member has manager or admin role"""
    if staff.role not in [StaffRole.MANAGER, StaffRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized. Manager or Admin role required."
        )

# Category routes
@router.get(
    "/categories",
    response_model=List[dict],
    summary="List All Categories",
    response_description="List of categories with their items"
)
async def list_categories(db: Session = Depends(get_db)):
    """
    Retrieve all menu categories.

    Returns a list of all categories, sorted by their display order.
    Each category includes its items and their modifier lists.

    Returns:
    - List of categories with nested items and modifiers
    """
    categories = db.query(Category).order_by(Category.sort_order).all()
    return [cat.to_dict() for cat in categories]

@router.post(
    "/categories",
    response_model=dict,
    status_code=status.HTTP_201_CREATED,
    summary="Create Category",
    response_description="Created category details"
)
async def create_category(
    category: CategoryCreate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """
    Create a new menu category.

    Requires manager or admin role.
    Categories are used to organize menu items.

    Parameters:
    - name: Category name
    - sort_order: Display order position

    Returns:
    - Created category details

    Raises:
    - 400: Category name already exists
    - 401: Not authenticated
    - 403: Not authorized (requires manager/admin)
    """
    check_manager_role(current_staff)
    
    if db.query(Category).filter(Category.name == category.name).first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Category with this name already exists"
        )
    
    db_category = Category(**category.dict())
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category.to_dict()

@router.put(
    "/categories/{category_id}",
    response_model=dict,
    summary="Update Category",
    response_description="Updated category details"
)
async def update_category(
    category_id: int,
    category: CategoryUpdate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """
    Update an existing category.

    Requires manager or admin role.
    Updates specified fields of the category.

    Parameters:
    - category_id: ID of category to update
    - name: New category name (optional)
    - sort_order: New display order (optional)
    - active: New availability status (optional)

    Returns:
    - Updated category details

    Raises:
    - 401: Not authenticated
    - 403: Not authorized (requires manager/admin)
    - 404: Category not found
    """
    check_manager_role(current_staff)
    
    db_category = db.query(Category).filter(Category.id == category_id).first()
    if not db_category:
        raise HTTPException(status_code=404, detail="Category not found")
    
    for field, value in category.dict(exclude_unset=True).items():
        setattr(db_category, field, value)
    
    db.commit()
    db.refresh(db_category)
    return db_category.to_dict()

# Item routes
@router.get(
    "/items",
    response_model=List[dict],
    summary="List Items",
    response_description="List of menu items"
)
async def list_items(
    category_id: Optional[int] = None,
    db: Session = Depends(get_db)
):
    """
    List all menu items.

    Optionally filter items by category.
    Returns items sorted by their display order.

    Parameters:
    - category_id: Optional category filter

    Returns:
    - List of items with their modifier lists
    """
    query = db.query(Item)
    if category_id:
        query = query.filter(Item.category_id == category_id)
    items = query.order_by(Item.sort_order).all()
    return [item.to_dict() for item in items]

@router.post(
    "/items",
    response_model=dict,
    status_code=status.HTTP_201_CREATED,
    summary="Create Item",
    response_description="Created item details"
)
async def create_item(
    item: ItemCreate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """
    Create a new menu item.

    Requires manager or admin role.
    Creates an item with optional modifier lists.

    Parameters:
    - name: Item name
    - category_id: Category this item belongs to
    - price: Base price
    - sort_order: Display order
    - mod_lists: Optional list of modifier groups

    Returns:
    - Created item details with modifiers

    Raises:
    - 401: Not authenticated
    - 403: Not authorized (requires manager/admin)
    - 404: Category not found
    """
    check_manager_role(current_staff)
    
    if not db.query(Category).filter(Category.id == item.category_id).first():
        raise HTTPException(status_code=404, detail="Category not found")
    
    mod_lists_data = item.mod_lists
    item_dict = item.dict(exclude={'mod_lists'})
    db_item = Item(**item_dict)
    db.add(db_item)
    db.flush()
    
    for mod_list_data in mod_lists_data:
        mods_data = mod_list_data.mods
        mod_list_dict = mod_list_data.dict(exclude={'mods'})
        db_mod_list = ModList(**mod_list_dict, item_id=db_item.id)
        db.add(db_mod_list)
        db.flush()
        
        for mod_data in mods_data:
            db_mod = Mod(**mod_data.dict(), mod_list_id=db_mod_list.id)
            db.add(db_mod)
    
    db.commit()
    db.refresh(db_item)
    return db_item.to_dict()

@router.put(
    "/items/{item_id}",
    response_model=dict,
    summary="Update Item",
    response_description="Updated item details"
)
async def update_item(
    item_id: int,
    item: ItemUpdate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """
    Update an existing menu item.

    Requires manager or admin role.
    Updates specified fields of the item.

    Parameters:
    - item_id: ID of item to update
    - name: New item name (optional)
    - category_id: New category (optional)
    - price: New base price (optional)
    - sort_order: New display order (optional)
    - active: New availability status (optional)

    Returns:
    - Updated item details

    Raises:
    - 401: Not authenticated
    - 403: Not authorized (requires manager/admin)
    - 404: Item or category not found
    """
    check_manager_role(current_staff)
    
    db_item = db.query(Item).filter(Item.id == item_id).first()
    if not db_item:
        raise HTTPException(status_code=404, detail="Item not found")
    
    if item.category_id is not None:
        if not db.query(Category).filter(Category.id == item.category_id).first():
            raise HTTPException(status_code=404, detail="Category not found")
    
    for field, value in item.dict(exclude_unset=True).items():
        setattr(db_item, field, value)
    
    db.commit()
    db.refresh(db_item)
    return db_item.to_dict()

# Modifier List routes
@router.post(
    "/items/{item_id}/modlists",
    response_model=dict,
    status_code=status.HTTP_201_CREATED,
    summary="Add Modifier List",
    response_description="Created modifier list details"
)
async def add_modifier_list(
    item_id: int,
    mod_list: ModListCreate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """
    Add a modifier list to an item.

    Requires manager or admin role.
    Creates a new modifier list with its modifiers.

    Parameters:
    - item_id: ID of item to add modifiers to
    - name: Modifier list name
    - min_selections: Minimum required selections
    - max_selections: Maximum allowed selections
    - sort_order: Display order
    - mods: List of modifiers

    Returns:
    - Created modifier list details

    Raises:
    - 401: Not authenticated
    - 403: Not authorized (requires manager/admin)
    - 404: Item not found
    """
    check_manager_role(current_staff)
    
    if not db.query(Item).filter(Item.id == item_id).first():
        raise HTTPException(status_code=404, detail="Item not found")
    
    mods_data = mod_list.mods
    mod_list_dict = mod_list.dict(exclude={'mods'})
    db_mod_list = ModList(**mod_list_dict, item_id=item_id)
    db.add(db_mod_list)
    db.flush()
    
    for mod_data in mods_data:
        db_mod = Mod(**mod_data.dict(), mod_list_id=db_mod_list.id)
        db.add(db_mod)
    
    db.commit()
    db.refresh(db_mod_list)
    return db_mod_list.to_dict()

@router.put(
    "/modlists/{mod_list_id}",
    response_model=dict,
    summary="Update Modifier List",
    response_description="Updated modifier list details"
)
async def update_modifier_list(
    mod_list_id: int,
    mod_list: ModListUpdate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """
    Update a modifier list.

    Requires manager or admin role.
    Updates specified fields of the modifier list.

    Parameters:
    - mod_list_id: ID of modifier list to update
    - name: New name (optional)
    - min_selections: New minimum selections (optional)
    - max_selections: New maximum selections (optional)
    - sort_order: New display order (optional)
    - active: New availability status (optional)

    Returns:
    - Updated modifier list details

    Raises:
    - 401: Not authenticated
    - 403: Not authorized (requires manager/admin)
    - 404: Modifier list not found
    """
    check_manager_role(current_staff)
    
    db_mod_list = db.query(ModList).filter(ModList.id == mod_list_id).first()
    if not db_mod_list:
        raise HTTPException(status_code=404, detail="Modifier list not found")
    
    for field, value in mod_list.dict(exclude_unset=True).items():
        setattr(db_mod_list, field, value)
    
    db.commit()
    db.refresh(db_mod_list)
    return db_mod_list.to_dict()

# Modifier routes
@router.post("/modlists/{mod_list_id}/mods", response_model=dict)
async def add_modifier(
    mod_list_id: int,
    mod: ModCreate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """Add a modifier to a modifier list"""
    check_manager_role(current_staff)
    
    # Check if modifier list exists
    if not db.query(ModList).filter(ModList.id == mod_list_id).first():
        raise HTTPException(status_code=404, detail="Modifier list not found")
    
    db_mod = Mod(**mod.dict(), mod_list_id=mod_list_id)
    db.add(db_mod)
    db.commit()
    db.refresh(db_mod)
    return db_mod.to_dict()

@router.put("/mods/{mod_id}", response_model=dict)
async def update_modifier(
    mod_id: int,
    mod: ModUpdate,
    current_staff: Staff = Depends(get_current_staff),
    db: Session = Depends(get_db)
):
    """Update a modifier"""
    check_manager_role(current_staff)
    
    db_mod = db.query(Mod).filter(Mod.id == mod_id).first()
    if not db_mod:
        raise HTTPException(status_code=404, detail="Modifier not found")
    
    # Update fields if provided
    for field, value in mod.dict(exclude_unset=True).items():
        setattr(db_mod, field, value)
    
    db.commit()
    db.refresh(db_mod)
    return db_mod.to_dict() 