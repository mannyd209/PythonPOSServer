from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from typing import List, Optional
from pydantic import BaseModel, Field, validator
from datetime import datetime, date

from models import Staff, StaffRole, StaffShift, get_db
from utils.auth import get_current_staff, verify_admin

router = APIRouter(
    prefix="/staff/admin",
    tags=["Staff Management"],
    responses={
        401: {"description": "Not authenticated"},
        403: {"description": "Not authorized (Admin only)"},
        404: {"description": "Staff member not found"}
    },
    dependencies=[Depends(verify_admin)]
)

class StaffCreate(BaseModel):
    """Staff creation model. ID is auto-generated by the backend."""
    name: str = Field(..., description="Staff member's name")
    pin: str = Field(..., min_length=4, max_length=4, description="4-digit PIN")
    hourly_rate: float = Field(..., gt=0, description="Hourly pay rate")
    isAdmin: bool = Field(default=False, description="Admin privileges")
    available: bool = Field(default=True, description="Whether this staff member is available")

    @validator('pin')
    def validate_pin(cls, v):
        if not v.isdigit():
            raise ValueError("PIN must contain only digits")
        return v

    class Config:
        json_schema_extra = {
            "example": {
                "name": "John Doe",
                "pin": "1234",
                "hourly_rate": 15.00,
                "isAdmin": False,
                "available": True
            }
        }

class StaffUpdate(BaseModel):
    """Staff update model. ID cannot be changed as it is auto-generated."""
    name: Optional[str] = Field(None, description="Staff member's name")
    pin: Optional[str] = Field(None, min_length=4, max_length=4, description="4-digit PIN")
    hourly_rate: Optional[float] = Field(None, gt=0, description="Hourly pay rate")
    isAdmin: Optional[bool] = Field(None, description="Admin privileges")
    available: Optional[bool] = Field(None, description="Whether this staff member is available")

    @validator('pin')
    def validate_pin(cls, v):
        if v is not None and not v.isdigit():
            raise ValueError("PIN must contain only digits")
        return v

    class Config:
        json_schema_extra = {
            "example": {
                "name": "John Doe",
                "hourly_rate": 16.00,
                "isAdmin": True,
                "available": True
            }
        }

def check_pin_unique(pin: str, db: Session, exclude_staff_id: int = None) -> bool:
    """Check if a PIN is unique among all staff members"""
    query = db.query(Staff).filter(Staff.pin == pin)
    if exclude_staff_id:
        query = query.filter(Staff.id != exclude_staff_id)
    return query.first() is None

@router.get(
    "",
    response_model=List[dict],
    summary="List Staff",
    response_description="List of staff members"
)
async def list_staff(
    active: Optional[bool] = None,
    working: Optional[bool] = None,
    db: Session = Depends(get_db)
):
    """Get all staff members with optional filters"""
    query = db.query(Staff)
    
    if active is not None:
        query = query.filter(Staff.available == active)
    
    if working is not None:
        query = query.filter(Staff.is_working == working)
    
    staff = query.all()
    return [s.to_dict() for s in staff]

@router.post(
    "",
    response_model=dict,
    summary="Create Staff",
    response_description="Created staff member details with auto-generated ID"
)
async def create_staff(staff_data: StaffCreate, db: Session = Depends(get_db)):
    """
    Create a new staff member.
    
    The staff ID will be auto-generated by the backend.
    The PIN must be unique across all staff members.
    """
    # Check if PIN is already in use
    existing = db.query(Staff).filter(Staff.pin == staff_data.pin).first()
    if existing:
        raise HTTPException(status_code=400, detail="PIN is already in use")
    
    staff = Staff(
        name=staff_data.name,
        pin=staff_data.pin,
        hourly_rate=staff_data.hourly_rate,
        isAdmin=staff_data.isAdmin,
        available=staff_data.available
    )
    
    db.add(staff)
    db.commit()
    db.refresh(staff)
    
    return staff.to_dict()

@router.patch(
    "/{staff_id}",
    response_model=dict,
    summary="Update Staff",
    response_description="Updated staff member details"
)
async def update_staff(
    staff_id: int,
    updates: StaffUpdate,
    db: Session = Depends(get_db)
):
    """Update staff member details"""
    staff = db.query(Staff).filter(Staff.id == staff_id).first()
    if not staff:
        raise HTTPException(status_code=404, detail="Staff member not found")
    
    if updates.pin is not None:
        existing = db.query(Staff).filter(
            Staff.pin == updates.pin,
            Staff.id != staff_id
        ).first()
        if existing:
            raise HTTPException(status_code=400, detail="PIN is already in use")
        staff.pin = updates.pin
    
    if updates.name is not None:
        if len(updates.name.strip()) == 0:
            raise HTTPException(status_code=400, detail="Name cannot be empty")
        staff.name = updates.name
    
    if updates.hourly_rate is not None:
        if updates.hourly_rate <= 0:
            raise HTTPException(status_code=400, detail="Hourly rate must be greater than 0")
        staff.hourly_rate = updates.hourly_rate
    
    if updates.isAdmin is not None:
        staff.isAdmin = updates.isAdmin
    if updates.available is not None:
        staff.available = updates.available
    
    db.commit()
    db.refresh(staff)
    
    return staff.to_dict()

@router.get(
    "/{staff_id}/earnings",
    response_model=dict,
    summary="Get Staff Earnings",
    response_description="Staff earnings for the specified period"
)
async def get_staff_earnings(
    staff_id: int,
    start_date: date,
    end_date: date,
    db: Session = Depends(get_db)
):
    """Get staff earnings for a period"""
    staff = db.query(Staff).filter(Staff.id == staff_id).first()
    if not staff:
        raise HTTPException(status_code=404, detail="Staff member not found")
    
    shifts = db.query(StaffShift).filter(
        StaffShift.staff_id == staff_id,
        StaffShift.clock_in >= start_date,
        StaffShift.clock_in < end_date
    ).all()
    
    total_earnings = 0.0
    total_hours = 0.0
    break_hours = 0.0
    shift_details = []
    
    for shift in shifts:
        earnings = shift.calculate_earnings()
        hours = shift.calculate_hours_worked()
        break_time = shift.calculate_break_hours()
        
        total_earnings += earnings
        total_hours += hours
        break_hours += break_time
        
        shift_details.append({
            "date": shift.clock_in.date().isoformat(),
            "clock_in": shift.clock_in.isoformat(),
            "clock_out": shift.clock_out.isoformat() if shift.clock_out else None,
            "break_hours": break_time,
            "earnings": earnings
        })
    
    return {
        "earnings": {
            "total_earnings": total_earnings,
            "total_hours": total_hours,
            "break_hours": break_hours,
            "shifts": shift_details
        }
    }

@router.delete(
    "/{staff_id}",
    response_model=dict,
    summary="Delete Staff",
    response_description="Result of staff deletion"
)
async def delete_staff(staff_id: int, db: Session = Depends(get_db)):
    """Deactivate a staff member"""
    staff = db.query(Staff).filter(Staff.id == staff_id).first()
    if not staff:
        raise HTTPException(status_code=404, detail="Staff member not found")
    
    staff.available = False
    db.commit()
    
    return {"success": True, "message": "Staff member deactivated"} 